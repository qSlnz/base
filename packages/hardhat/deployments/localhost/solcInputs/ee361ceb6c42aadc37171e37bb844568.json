{
  "language": "Solidity",
  "sources": {
    "contracts/Staker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.4;\n\ncontract Staker {\n    /*************\n     * VARIABLES *\n     *************/\n\n    uint256 public poolCount = 0;\n\n    struct Pool {\n        uint256 threshold;\n        uint256 deadline;\n        uint256 totalStaked;\n        address payable sendTo;\n        bool executed;\n    }\n\n    mapping(uint256 => Pool) public pools;\n\n    /* balance for a specific address and pool */\n    mapping(address => mapping(uint256 => uint256)) public balances;\n    /* locking no reentrency */\n    bool private lock = false;\n\n    /**********\n     * EVENTS *\n     **********/\n\n    event Stake(\n        uint256 indexed poolId,\n        address indexed staker,\n        uint256 indexed amount\n    );\n    event PoolCreation(uint256 indexed poolId, address indexed staker);\n    event PoolExecuted(uint256 indexed poolId);\n    event PoolWithdraw(uint256 indexed poolId, address indexed staker);\n\n    /*************\n     * MODIFIERS *\n     *************/\n\n    modifier poolExists(uint256 _poolId) {\n        require(_poolId < poolCount, \"Wtf bro this pool has never existed\");\n        _;\n    }\n\n    modifier poolIsEnded(uint256 _poolId) {\n        require(\n            pools[_poolId].deadline < block.timestamp,\n            \"This pool is live bro\"\n        );\n        _;\n    }\n\n    modifier poolIsLive(uint256 _poolId) {\n        require(\n            pools[_poolId].deadline >= block.timestamp,\n            \"This pool is done bro\"\n        );\n        _;\n    }\n\n    modifier reentrancyGuard() {\n        require(!lock, \"Liar! Cheater! Thief!\");\n        lock = true;\n        _;\n        lock = false;\n    }\n\n    /*************\n     * FUNCTIONS *\n     *************/\n\n    /* return poolid */\n    function createPool(\n        uint256 _threshold,\n        uint256 _deadline,\n        address payable _sendTo\n    ) public returns (uint256) {\n        require(_deadline > 0);\n        require(_sendTo != address(0));\n\n        uint256 poolId = poolCount;\n        poolCount++;\n\n        Pool memory newPool;\n        newPool.threshold = _threshold * 1 wei;\n        newPool.deadline = block.timestamp + _deadline * 1 seconds;\n        newPool.executed = false;\n        newPool.sendTo = _sendTo;\n\n        pools[poolId] = newPool;\n\n        emit PoolCreation(poolId, msg.sender);\n\n        return poolId;\n    }\n\n    function stake(uint256 _poolId)\n        public\n        payable\n        poolExists(_poolId)\n        poolIsLive(_poolId)\n    {\n        require(msg.value > 0, \"Gimme yo money bro\");\n\n        balances[msg.sender][_poolId] += msg.value;\n        pools[_poolId].totalStaked += msg.value;\n\n        emit Stake(_poolId, msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 _poolId)\n        public\n        poolExists(_poolId)\n        poolIsEnded(_poolId)\n        reentrancyGuard()\n    {\n        require(\n            pools[_poolId].totalStaked < pools[_poolId].threshold,\n            \"The pool is a success, your ethers are mine hahaha. bro.\"\n        );\n\n        uint256 amountToWithdraw = balances[msg.sender][_poolId];\n\n        require(amountToWithdraw > 0, \"Nothing you can withdraw here\");\n\n        (bool success, ) = msg.sender.call{value: amountToWithdraw}(\"\");\n\n        require(success, \"Sending money failed\");\n\n        balances[msg.sender][_poolId] = 0;\n\n        emit PoolWithdraw(_poolId, msg.sender);\n    }\n\n    function execute(uint256 _poolId)\n        public\n        poolExists(_poolId)\n        poolIsEnded(_poolId)\n        reentrancyGuard()\n    {\n        require(!pools[_poolId].executed, \"The pool has already been executed\");\n        require(\n            pools[_poolId].totalStaked >= pools[_poolId].threshold,\n            \"The pool didnt reach the threshold amout, go withdraw your ethers using withdraw function bro\"\n        );\n\n        uint256 amountToWithdraw = pools[_poolId].totalStaked;\n        (bool success, ) =\n            pools[_poolId].sendTo.call{value: amountToWithdraw, gas: gasleft()}(\n                \"\"\n            );\n\n        require(success, \"Sending money failed\");\n\n        pools[_poolId].executed = true;\n\n        emit PoolExecuted(_poolId);\n    }\n\n    function isParticipatingTo(uint256 _poolId, address _addr)\n        public\n        view\n        poolExists(_poolId)\n        returns (bool)\n    {\n        if (balances[_addr][_poolId] > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function timeleft(uint256 _poolId)\n        public\n        view\n        poolExists(_poolId)\n        returns (uint256)\n    {\n        int256 timel =\n            int256(pools[_poolId].deadline) - int256(block.timestamp);\n        if (timel > 0) {\n            return uint256(timel);\n        } else {\n            return 0;\n        }\n    }\n\n    // TODO > handle case MAX_UINT256 reached\n    // Question: I use uint256, but if I use uint64 for example, I will use less gas on smartcontract creation and method call that use it?\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}